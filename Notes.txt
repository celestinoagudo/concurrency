The Problem with Platform Threads:
- Platform Threads = OS Threads
- Each thread needs its own memory stack
- Heavy and expensive to create.
- OS limits how many you can run.
- Not built for large scale concurrency.

Virtual Threads
- Lightweight and memory efficient.
- enable massive concurrency

Process
- An instance of a computer program
- includes code, resources (allocated by the OS like memory, sockets .. etc)
- heavyweight

Thread
- part of the process: contains one or more threads, process is a unit of resources
- threads within a process can share the memory space. Thread is a unit of execution

OS Scheduler
- assign the thread to CPU for execution, determines how long the tread should execute.

CPU/Processor: can be used interchangeably, modern CPU comes with multiple cores, each core can be seen as a processor.

Context Switch: Scheduler selects which thread to execute. When switching, the current thread's execution point's state has to be stored, so that it can be resume later from the point where it was stopped.

Kernel Thread/OS Thread

Java (Platform) Thread
- 1 Java Thread = 1 OS Thread
- Remember: OS Thread is the unit of scheduling
- Java Thread is a wrapper to the OS Thread.

Stack memory: method specific local variables, function calls information should be stored somewhere
	- Heap vs. Stack: Heap stores objects we dynamically create: ArrayList, Hasmap
	- Stack contains: local variables, object references and function call information
	- each thread has its own stack memory, the size of stack memory is determined when the process starts or thread is created. Given upfront, cannot be modified
	- default 1 MB for every single thread, varies depending on the CPU architecture and the OS.
	- whether thread is doing something or not, an appropriate memory is allocated.

Where's the problem?
- Microservices architecture: involves network calls, we're creating an expensive thread, but we're keeping it idle. The problem we're trying to solve with virtual threads.

-Xss: stack size argument

daemon thread: runs in the background

Virtual Thread
	- simply an illusion provided by Java
		- it looks like a thread.
		- it will accept a runnable
		- we can do thread.start, thread.join
		- but OS can't see them / schedule them.
	- nothing is created in the OS level, tiny objects we create in the heap.
	- see them as a task.
	- when thread.start, all tasks will be added to a queue internally, cannot execute on its own and cannot be seen by the OS
	- Fork Join pool - number of threads depends on the processor we have on our machine.
	- platform thread gets the task from the queue and start executing 
	- platform thread whenever sees blocking I/O task: network call, it will park the task and proceed to take remaining tasks from the queue, goal is platform thread should not be blocked. VT must be mounted on a Carrier thread to execute the task (mounting)
	- when response comes back (to parked task), it will be put in the queue and resumes the execution where it was stopped.
	- no guarantee that same carrier thread will process the same virtual thread from start to finish.
	- Virtual threads do not have fixed stack; they have resizable stack: Stack Chunk Object.

Virtual Thread Scheduler
- platform threads are scheduled by the OS Scheduler
- virtual threads are scheduled by the JVM
	- dedicated forkjoinpool to schedule virtual threads
		- core pool size: available processors.
		- carrier threads will not be blocked during I/O
- system properties:
	- jdk.virtualThreadScheduler.parallelism=Runtime.getRuntime().availableProcessors();
	- jdk.virtualThreadScheduler.maxPoolSize=256

Scheduling Types
- preeemtive - OS Scheduling policy
	- CPU is allocated for a limited time.
	- OS can forcibly pause a running thread to give CPU to another thread.
	- based on thread prio, time slice, availability of ready to run threads
	- priorities:
		- low: 1
		- 10: high
		- 5: default
	- note: preemptive scheduling behavior is platform dependent
	- virtual threads have default priority: cannot be modified
- cooperative
	- CPU is allocated till the execution is completed.
		- or thread should be willing to give CPU to another thread. Thread.yield
	- execution is not interrupted/forcibly paused.
	- if there's a long running thread/task, other threads might have to starve.

Synchronization
- Mechanism to provide controlled access to shared resources/critical section of code in multi-threaded environment to prevent race conditions / data corruption
- All applicable multi-thread related challenges like race conditions, dead-locks are still applicable for virtual threads.

Thread Pinning
- if a virtual thread enters synchronized method it cannot be unmounted until the synchronized section finishes. Or Native while executing native code.
- this prevents the JVM from switching to another VT and reduces scalability.

ReentrantLock: Fairness
- works like synchronized, but provides more flexibility and control.
- fairness policy: a thrad which has been waiting longer will get the chance to acquire the lock.
- tryLock with timeout: max time for a thread to wait to acquire the lock.

ExecutorService

	High level concurrency framework
		- thread management
		- task management
	- Executor: FI, ExecutorService an interface which extends Executor
	- Executors: utility class with factory methods to create an instance of ExecutorService impl.
	- VT are not supposed to be pooled
		- Tasks
		- VT is intended to be created on demand and discard once the task is done.
	- Then what is the use of ExecutorService with VT?
		- Thread per task creation management.

ExecutorService Types
	- Fixed Thread Pool: A TP with dedicated number of threads
	- Single Thread Executor: execute tasks sequentially. A TP with single worker thread
	- Cached thread pool: elastic TP. Create new thread on demand, reuse existing thread if available. Idle thread time is 1 min. Usage: unpredictable workload
	- Scheduled TP: can be used to run at regular interval, call remote service every minute.
	- Thread per task executor: creates new thread per task on demand. since: 21

Are we supposed to use ExecutorService with try-with-resources always?
	- it depends: if you're already using shutdown, then you can use try
	- spring web / server applications, ExecutorService will be used throughout the application. We do not shutdown.

Concurrency: dealing with multiple task over a period of time.
Parallelism: we might want to breakdown a task into smaller multiple subtasks so that they can all be processed independently to achieve significant improvement in the performance.

ExecutorService challenges
- Executor Service
	- Platform Threads
		- single / fixed / cached / scheduled / fork-join-pool (for CPU tasks)
	- virtual threads
		- thread per task executor
	- VT: great for IO tasks to achieve non-blocking benefits behind the scenes. 

Semaphore: behaves like ReentrantLock
- Are these the same?
	- Semaphore semaphore = new Semaphore(1);
	- Lock lock = new ReentrantLock();
- Lock: the thread which acquired the lock is supposed to unlock
- Semaphore: Any thread can release the permit.

ExecutorService with Platform Threads:
	- single / fixed / cached / scheduled / fork-join-pool
	- these implementations pool threads.
	- do not use VT factory.
ExecutorService with VT
	- single / fixed -> use semaphore + queue
	- cached -> more or less same as thread per task
	- scheduled -> use platform thread to schedule and virtual thread to execute
	- fork join pool -> N/A

CompletableFuture by default uses Fork-join pool.
	- it accepts an Executor. We can use virtual-thread-per-task executor.


ThreadLocal
- is like a locker / storage space for each thread.
- each thread can store and access its value independent of other threads.
- works with platform / virtual
- No need to pass data through method calls
	- Data that belongs to the entire thread's execution flow (request id, security context, txn context) can be stored in thread local and accessed anywhere in that thread.
- Some objects are not thread safe and expensive to create
	- ObjectMapper (older versions)
	- synchronized can hurt performance.
- Design flaws:
	- mutable
	- object in thread local maybe retained event not in use.
		- fixed thread pool - 500
	- child thread inheritance is expensive
- should be used with static final - but people misuse.

Is ThreadLocal bad?
	- Problems arise when developers use it without discipline
		- you must call the remove method
		- the set method mutates the value, which can lead to unexpected behavior if different parts of the thread overwrite it.

Golden Rules
	- do not use the ThreadLocal directly. Always wrap it inside a helper / holder class.
	- keep mutation methods private (package private)
		- only trusted code call set() or remove()
	- set and remove must always go together. Never set w/out removing.
	- use ThreadLocal only for cross-cutting concerns / non-functional data
		(e.g. security context, request metadata, tracing info.) 

Scoped Values
- Safe, predictable, and efficient way to attach execution-scoped data without relying on developer discipline.
- values are bound to the current thread just before the runnable (callable) starts.
- values are unbound automatically when the runnable or callable completes (no manual cleanup needed)