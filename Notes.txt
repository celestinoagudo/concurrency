The Problem with Platform Threads:
- Platform Threads = OS Threads
- Each thread needs its own memory stack
- Heavy and expensive to create.
- OS limits how many you can run.
- Not built for large scale concurrency.

Virtual Threads
- Lightweight and memory efficient.
- enable massive concurrency

Process
- An instance of a computer program
- includes code, resources (allocated by the OS like memory, sockets .. etc)
- heavyweight

Thread
- part of the process: contains one or more threads, process is a unit of resources
- threads within a process can share the memory space. Thread is a unit of execution

OS Scheduler
- assign the thread to CPU for execution, determines how long the tread should execute.

CPU/Processor: can be used interchangeably, modern CPU comes with multiple cores, each core can be seen as a processor.

Context Switch: Scheduler selects which thread to execute. When switching, the current thread's execution point's state has to be stored, so that it can be resume later from the point where it was stopped.

Kernel Thread/OS Thread

Java (Platform) Thread
- 1 Java Thread = 1 OS Thread
- Remember: OS Thread is the unit of scheduling
- Java Thread is a wrapper to the OS Thread.

Stack memory: method specific local variables, function calls information should be stored somewhere
	- Heap vs. Stack: Heap stores objects we dynamically create: ArrayList, Hasmap
	- Stack contains: local variables, object references and function call information
	- each thread has its own stack memory, the size of stack memory is determined when the process starts or thread is created. Given upfront, cannot be modified
	- default 1 MB for every single thread, varies depending on the CPU architecture and the OS.
	- whether thread is doing something or not, an appropriate memory is allocated.

Where's the problem?
- Microservices architecture: involves network calls, we're creating an expensive thread, but we're keeping it idle. The problem we're trying to solve with virtual threads.

-Xss: stack size argument

daemon thread: runs in the background

Virtual Thread
	- simply an illusion provided by Java
		- it looks like a thread.
		- it will accept a runnable
		- we can do thread.start, thread.join
		- but OS can't see them / schedule them.
	- nothing is created in the OS level, tiny objects we create in the heap.
	- see them as a task.
	- when thread.start, all tasks will be added to a queue internally, cannot execute on its own and cannot be seen by the OS
	- Fork Join pool - number of threads depends on the processor we have on our machine.
	- platform thread gets the task from the queue and start executing 
	- platform thread whenever sees blocking I/O task: network call, it will park the task and proceed to take remaining tasks from the queue, goal is platform thread should not be blocked. VT must be mounted on a Carrier thread to execute the task (mounting)
	- when response comes back (to parked task), it will be put in the queue and resumes the execution where it was stopped.
	- no guarantee that same carrier thread will process the same virtual thread from start to finish.
	- Virtual threads do not have fixed stack; they have resizable stack: Stack Chunk Object.

Virtual Thread Scheduler
- platform threads are scheduled by the OS Scheduler
- virtual threads are scheduled by the JVM
	- dedicated forkjoinpool to schedule virtual threads
		- core pool size: available processors.
		- carrier threads will not be blocked during I/O
- system properties:
	- jdk.virtualThreadScheduler.parallelism=Runtime.getRuntime().availableProcessors();
	- jdk.virtualThreadScheduler.maxPoolSize=256

Scheduling Types
- preeemtive - OS Scheduling policy
	- CPU is allocated for a limited time.
	- OS can forcibly pause a running thread to give CPU to another thread.
	- based on thread prio, time slice, availability of ready to run threads
	- priorities:
		- low: 1
		- 10: high
		- 5: default
	- note: preemptive scheduling behavior is platform dependent
	- virtual threads have default priority: cannot be modified
- cooperative
	- CPU is allocated till the execution is completed.
		- or thread should be willing to give CPU to another thread. Thread.yield
	- execution is not interrupted/forcibly paused.
	- if there's a long running thread/task, other threads might have to starve.

Synchronization
- Mechanism to provide controlled access to shared resources/critical section of code in multi-threaded environment to prevent race conditions / data corruption
- All applicable multi-thread related challenges like race conditions, dead-locks are still applicable for virtual threads.

Thread Pinning
- if a virtual thread enters synchronized method it cannot be unmounted until the synchronized section finishes. Or Native while executing native code.
- this prevents the JVM from switching to another VT and reduces scalability.

ReentrantLock: Fairness
- works like synchronized, but provides more flexibility and control.
- fairness policy: a thrad which has been waiting longer will get the chance to acquire the lock.
- tryLock with timeout: max time for a thread to wait to acquire the lock.
